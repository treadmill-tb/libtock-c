#include <stdbool.h>
#include <stdio.h>
#include <string.h>

#include <libtock-sync/services/alarm.h>
#include <libtock/interface/button.h>
#include <libtock/kernel/ipc.h>
#include <libtock/tock.h>

// Use a large buffer near the top of process memory
// This increases chances of it being in the region affected by grants
#define BUFFER_SIZE 256

// This buffer is placed at a high memory address to increase the chance
// that after a restart, grants will overlap with it
static char shared_buffer[BUFFER_SIZE] __attribute__((aligned(16)));
static size_t server_svc = 0;

// Global flag to detect button presses
static bool button_pressed = false;
static int pressed_button = 0;

// Restart counter (will reset on crash)
static int restart_count = 0;

// Fill the buffer with a recognizable pattern
static void initialize_buffer() {
  // Clear buffer
  memset(shared_buffer, 0, BUFFER_SIZE);

  // Fill with a recognizable pattern - repeated "CLIENT-DATA-" with position
  // number
  for (int i = 0; i < BUFFER_SIZE - 12; i += 12) {
    snprintf(&shared_buffer[i + 1], 12, "CLIENT-DATA");
  }

  // First byte is reserved for command
  shared_buffer[0] = 0;

  printf("Client: Buffer initialized with pattern at %p\n", shared_buffer);
}

// IPC callback for responses from the server
static void server_callback(__attribute__((unused)) int pid,
                            __attribute__((unused)) int len,
                            __attribute__((unused)) int arg2,
                            __attribute__((unused)) void *ud) {
  printf("Client: Received response from server\n");
}

// Button press callback
static void button_callback(__attribute__((unused)) returncode_t ret, int num,
                            bool val) {
  if (val) { // Button pressed
    pressed_button = num;
    button_pressed = true;
  }
}

// Function to trigger a crash
static void trigger_crash(void) {
  printf("Client: Triggering crash by division by zero...\n");
  printf(
      "Client: After restart, check if the high water mark was preserved.\n");
  printf("Client: If vulnerability exists, server will detect kernel memory in "
         "the buffer.\n");
  printf("Client: If fix works, server will still see original client data.\n");

  // Cause division by zero to crash
  volatile int x = 1;
  volatile int y = 0;
  volatile int z = x / y; // This will crash

  // This should never execute
  printf("Result: %d\n", z);
}

// Try to allocate a lot of small grants to increase chances of overwriting the
// buffer
static void allocate_many_grants(void) {
  // This is a dummy function that would normally try to allocate many small
  // grants to increase the chances of the vulnerability being exposed
  printf("Client: Would allocate many grants here to increase chance of "
         "vulnerability\n");
  printf("Client: (In a real test, we would make syscalls that allocate "
         "grants)\n");
}

int main(void) {
  printf("\nVulnerability Demo Client (Restart count: %d)\n", restart_count);
  restart_count++; // Increment restart count - will reset if process crashes

  // Initialize buffer
  initialize_buffer();

  // Setup button handlers
  libtock_button_notify_on_press(0, button_callback);
  libtock_button_notify_on_press(1, button_callback);

  printf("Client: Discovering server service...\n");

  // Discover the server service
  int retry = 0;
  int err = -1;
  while (err < 0 && retry < 30) { // Increase to 30 retries
    err = ipc_discover("server", &server_svc);
    if (err < 0) {
      libtocksync_alarm_delay_ms(200); // Increase delay to 200ms
      retry++;
    }
  }

  if (err < 0) {
    printf("Client: Failed to discover server service after %d retries\n",
           retry);
    return -1;
  }

  printf("Client: Found server at service %d\n", server_svc);

  // Register callback for server responses
  ipc_register_client_callback(server_svc, server_callback, NULL);

  // Share buffer with server
  printf("Client: Sharing buffer at %p with server\n", shared_buffer);
  ipc_share(server_svc, shared_buffer, BUFFER_SIZE);

  // Register buffer with server (command 0)
  shared_buffer[0] = 0;
  ipc_notify_service(server_svc);

  printf("Client: Setup complete. Press buttons to interact:\n");
  printf("  Button 0: Tell server to examine the buffer\n");
  printf("  Button 1: Trigger crash/restart to test vulnerability\n");

  // Main loop
  while (1) {
    // Wait for button press
    button_pressed = false;
    yield_for(&button_pressed);

    if (pressed_button == 0) {
      // Button 0: Tell server to read buffer
      printf("Client: Requesting server to examine buffer...\n");
      shared_buffer[0] = 1; // Command 1: Examine buffer
      ipc_notify_service(server_svc);
    } else if (pressed_button == 1) {
      // Button 1: Trigger crash
      allocate_many_grants(); // Try to make the vulnerability more likely to
                              // manifest
      trigger_crash();
    }

    // Add delay to prevent button bounce
    libtocksync_alarm_delay_ms(200);
  }

  return 0;
}
