#include <stdbool.h>
#include <stdio.h>
#include <string.h>

#include <libtock-sync/services/alarm.h>
#include <libtock/interface/led.h>
#include <libtock/kernel/ipc.h>
#include <libtock/tock.h>

// Buffer to store a reference to the client's shared memory
static char *client_buffer = NULL;
static size_t client_buffer_len = 0;
static int client_pid = 0;

// Helper function to print buffer contents in hex
static void print_buffer_hex(const char *buffer, size_t len) {
  printf("Buffer contents (hex): ");
  for (size_t i = 0; i < len && i < 64; i++) {
    printf("%02x ", (unsigned char)buffer[i]);
    // Print newline every 16 bytes for readability
    if ((i + 1) % 16 == 0)
      printf("\n                     ");
  }
  printf("\n");
}

// Handle commands from clients
static void ipc_callback(int pid, int len, int buf,
                         __attribute__((unused)) void *ud) {
  char *buffer = (char *)buf;

  // First byte is command
  if (len < 1) {
    return;
  }

  uint8_t command = buffer[0];

  switch (command) {
  case 0: // Register client buffer
    // Store the client's buffer reference
    client_buffer = buffer;
    client_buffer_len = len;
    client_pid = pid;
    printf("Server: Client registered buffer at %p, length %d\n", client_buffer,
           client_buffer_len);

    // Print initial buffer contents as baseline
    printf("Server: Initial ");
    print_buffer_hex(client_buffer,
                     client_buffer_len > 64 ? 64 : client_buffer_len);

    // Acknowledge
    buffer[0] = 0;
    ipc_notify_client(pid);
    break;

  case 1: // Examine buffer (used after client restart)
    if (client_buffer == NULL) {
      printf("Server: No client buffer registered\n");
      break;
    }

    printf("Server: Examining buffer after client restart\n");
    print_buffer_hex(client_buffer,
                     client_buffer_len > 64 ? 64 : client_buffer_len);

    // Now check for evidence of the vulnerability
    bool found_kernel_data = false;
    bool has_null_bytes = false;
    bool has_pointers = false;

    // Look for patterns indicating kernel memory:
    // 1. Grant pointer entries: pairs of 4 or 8 byte aligned addresses
    // 2. Runs of nulls followed by non-nulls (common in kernel structs)
    // 3. Values that look like pointers (high addresses)
    for (size_t i = 0; i < client_buffer_len - 4; i++) {
      // Check for null bytes pattern (padding in structs)
      if (client_buffer[i] == 0 && client_buffer[i + 1] == 0) {
        has_null_bytes = true;
      }

      // Check for potential pointer values (non-zero and aligned address)
      uint32_t potential_ptr = 0;
      memcpy(&potential_ptr, &client_buffer[i], 4);
      if (potential_ptr != 0 && (potential_ptr & 0x3) == 0 && // 4-byte aligned
          potential_ptr > 0x20000000) { // Typical RAM address range
        has_pointers = true;
      }
    }

    // If we found evidence of both patterns, likely kernel memory
    found_kernel_data = has_null_bytes && has_pointers;

    if (found_kernel_data) {
      printf("!!! VULNERABILITY DETECTED !!!\n");
      printf("Buffer appears to contain kernel memory structures!\n");
      printf("This indicates the grant region has grown into the previously "
             "shared memory.\n");

      // Visual indicator - blink LED rapidly
      for (int i = 0; i < 10; i++) {
        libtock_led_on(0);
        libtocksync_alarm_delay_ms(100);
        libtock_led_off(0);
        libtocksync_alarm_delay_ms(100);
      }
      libtock_led_on(0); // Leave LED on to indicate problem
    } else {
      printf(
          "âœ“ SECURE: Buffer still contains original client data or zeroes\n");
      printf("The fix appears to be working correctly.\n");

      // Visual indicator - LED stays off
      libtock_led_off(0);
    }

    // Acknowledge
    buffer[0] = 1;
    ipc_notify_client(pid);
    break;
  }
}

int main(void) {
  printf("Vulnerability Demo Server starting...\n");

  // Initialize LED
  libtock_led_off(0);

  // Register as a service
  int test = ipc_register_service_callback("server", ipc_callback, NULL);

  printf("\n\n\n\ntest!: %d\n\n\n\n", test);

  printf("Server registered. Waiting for clients...\n");

  // Main loop
  while (1) {
    yield();
  }

  return 0;
}
