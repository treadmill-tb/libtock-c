#include <stdbool.h>
#include <stdio.h>
#include <string.h>

#include <libtock-sync/services/alarm.h>
#include <libtock/interface/led.h>
#include <libtock/kernel/ipc.h>
#include <libtock/tock.h>

// Global state
static char *client_buffer = NULL;
static size_t client_buffer_len = 0;
static int client_pid = -1;

// Very minimal buffer printing - just print length and address, no contents
static void print_buffer_info(const char *buffer, size_t len) {
  printf("Buffer at %p with length %zu\n", (void *)buffer, len);
}

// Handle commands from clients - VERY minimal
static void ipc_callback(int pid, int len, int buf, void *ud) {
  printf("Server: IPC callback from pid=%d, len=%d, buf=%p\n", pid, len,
         (void *)buf);

  if (len < 1) {
    printf("Server: Message too short\n");
    return;
  }

  char *buffer = (char *)buf;
  uint8_t command = buffer[0];

  printf("Server: Command %d received\n", command);

  // IMPORTANT: Store references but DO NOT try to access buffer contents yet
  client_buffer = buffer;
  client_buffer_len = len;
  client_pid = pid;

  // Just acknowledge (set command byte back to itself)
  buffer[0] = command;

  printf("Server: Sending acknowledgment back to client\n");
  ipc_notify_client(pid);

  // After sharing is complete, print buffer info (not contents)
  printf("Server: Registered client %d buffer at %p with length %d\n", pid,
         client_buffer, client_buffer_len);
  print_buffer_info(client_buffer, client_buffer_len);
}

int main(void) {
  printf("Vulnerability Demo Server starting...\n");

  // Initialize LED
  libtock_led_off(0);

  // Register as a service
  printf("Server: Registering IPC service 'server'...\n");
  int result = ipc_register_service_callback("server", ipc_callback, NULL);
  printf("Server: Registration result = %d\n", result);
  printf("Server: Waiting for clients...\n");

  // Main loop
  while (1) {
    yield();
  }

  return 0;
}
