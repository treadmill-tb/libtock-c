#include <stdbool.h>
#include <stdio.h>
#include <string.h>

#include <libtock-sync/services/alarm.h>
#include <libtock/interface/led.h>
#include <libtock/kernel/ipc.h>
#include <libtock/tock.h>

// Buffer to store a reference to the client's shared memory
static char *client_buffer = NULL;
static size_t client_buffer_len = 0;
static int client_pid = 0;

// Helper function to print buffer contents in hex and ASCII
static void print_buffer_detailed(const char *buffer, size_t len) {
  printf("Buffer contents (hex and ASCII):\n");

  // Print in rows of 16 bytes
  for (size_t i = 0; i < len && i < 128; i += 16) {
    // Print address
    printf("%p: ", buffer + i);

    // Print hex values
    for (size_t j = i; j < i + 16 && j < len; j++) {
      printf("%02x ", (unsigned char)buffer[j]);
      if (j == i + 7)
        printf(" "); // Extra space after 8 bytes
    }

    // Pad if incomplete row
    size_t padding = 16 - (len - i < 16 ? len - i : 16);
    for (size_t p = 0; p < padding; p++) {
      printf("   ");
    }

    // Print ASCII representation
    printf(" |");
    for (size_t j = i; j < i + 16 && j < len; j++) {
      char c = buffer[j];
      if (c >= 32 && c <= 126) { // Printable ASCII
        printf("%c", c);
      } else {
        printf(".");
      }
    }
    printf("|\n");
  }
}

// Check if memory appears to contain kernel pointers or structures
static bool detect_kernel_memory(const char *buffer, size_t len) {
  int pointer_count = 0;
  int zero_sequences = 0;
  int non_ascii_sequences = 0;

  // Look for potential kernel pointers (values in the kernel memory range)
  for (size_t i = 0; i < len - 4; i += 4) {
    uint32_t value;
    memcpy(&value, &buffer[i], sizeof(uint32_t));

    // Check if value looks like a kernel pointer
    // Most ARM systems have kernel memory in the 0x20000000 range
    if (value >= 0x20000000 && value <= 0x20030000) {
      pointer_count++;
      printf("Potential kernel pointer at offset %zu: 0x%08x\n", i, value);
    }
  }

  // Check for patterns of zeros followed by non-zeros (common in structs)
  for (size_t i = 0; i < len - 8; i++) {
    if (buffer[i] == 0 && buffer[i + 1] == 0 && buffer[i + 2] == 0 &&
        buffer[i + 3] == 0 &&
        (buffer[i + 4] != 0 || buffer[i + 5] != 0 || buffer[i + 6] != 0 ||
         buffer[i + 7] != 0)) {
      zero_sequences++;
    }
  }

  // Check for high concentrations of non-ASCII values
  // Client data should be mostly ASCII, kernel data often isn't
  for (size_t i = 0; i < len; i++) {
    unsigned char c = (unsigned char)buffer[i];
    if (c > 127 || (c < 32 && c != 0 && c != '\n' && c != '\r' && c != '\t')) {
      non_ascii_sequences++;
    }
  }

  printf("Memory analysis results:\n");
  printf("  Potential kernel pointers: %d\n", pointer_count);
  printf("  Zero->nonzero sequences: %d\n", zero_sequences);
  printf("  Non-ASCII characters: %d\n", non_ascii_sequences);

  // Make a determination if this looks like kernel memory
  return (pointer_count >= 1 ||
          (zero_sequences >= 2 && non_ascii_sequences > 10));
}

// Handle commands from clients
static void ipc_callback(int pid, int len, int buf,
                         __attribute__((unused)) void *ud) {
  char *buffer = (char *)buf;

  // First byte is command
  if (len < 1) {
    return;
  }

  uint8_t command = buffer[0];

  switch (command) {
  case 0: // Register client buffer
    // Store the client's buffer reference
    client_buffer = buffer;
    client_buffer_len = len;
    client_pid = pid;
    printf("Server: Client %d registered buffer at %p, length %d\n", pid,
           client_buffer, client_buffer_len);

    // Print initial buffer contents as baseline
    printf("Server: Initial ");
    print_buffer_detailed(client_buffer,
                          client_buffer_len > 64 ? 64 : client_buffer_len);

    // Acknowledge
    buffer[0] = 0;
    ipc_notify_client(pid);
    break;

  case 1: // Examine buffer (used after client restart)
    if (client_buffer == NULL) {
      printf("Server: No client buffer registered\n");
      break;
    }

    printf("Server: Examining buffer at %p (len %d) after client action\n",
           client_buffer, client_buffer_len);

    // Print buffer contents for analysis
    print_buffer_detailed(client_buffer,
                          client_buffer_len > 128 ? 128 : client_buffer_len);

    // Analyze memory for signs of kernel memory contents
    bool found_kernel_data =
        detect_kernel_memory(client_buffer, client_buffer_len);

    // Look for the original client data pattern
    bool has_client_pattern = false;
    for (size_t i = 0; i < client_buffer_len - 10; i++) {
      if (strncmp(client_buffer + i, "CLIENT-DATA", 11) == 0) {
        has_client_pattern = true;
        break;
      }
    }

    if (found_kernel_data) {
      printf("!!! VULNERABILITY DETECTED !!!\n");
      printf("Buffer appears to contain kernel memory structures!\n");
      printf("This confirms the vulnerability in Issue #4371.\n");
      printf("The kernel grant region has grown into the previously shared "
             "memory.\n");

      // Visual indicator - blink LED rapidly
      for (int i = 0; i < 10; i++) {
        libtock_led_on(0);
        libtocksync_alarm_delay_ms(100);
        libtock_led_off(0);
        libtocksync_alarm_delay_ms(100);
      }
      libtock_led_on(0); // Leave LED on to indicate problem
    } else if (has_client_pattern) {
      printf("âœ“ SECURE: Buffer still contains original client data\n");
      printf("The vulnerability does not appear to be present.\n");
      libtock_led_off(0);
    } else {
      printf("? UNCERTAIN: Buffer doesn't contain client pattern or clear "
             "kernel data\n");
      printf("Memory may have been zeroed but not yet reused for kernel "
             "structures.\n");
      libtock_led_off(0);
    }

    // Acknowledge
    buffer[0] = 1;
    ipc_notify_client(pid);
    break;
  }
}

int main(void) {
  printf("Vulnerability Demo Server starting...\n");

  // Initialize LED
  libtock_led_off(0);

  // Register as a service
  int result = ipc_register_service_callback("server", ipc_callback, NULL);
  printf("Server registered with result: %d\n", result);
  printf("Server registered. Waiting for clients...\n");

  // Main loop
  while (1) {
    yield();
  }

  return 0;
}
